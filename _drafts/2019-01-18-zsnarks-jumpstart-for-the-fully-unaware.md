---
layout: single
title:  "zkSNARKs jumpstart for the fully unaware"
date:   2018-09-30 12:54:47 +0200
categories: [DLT, blockchain, zkSNARKs, Quora, Ethereum]
---
This post hopes to provide a first jump-start into ZK and zkSNARKs for people (like me) that are just starting to try and grasp it. It originated as an exercise in understanding and summarizing the following two fantastic write-ups and is heavily based upon them: [zkSNARKs in a nutshell](https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/) by Christian Reitwiessner and [Introduction to zk-SNARKs with examples](https://media.consensys.net/introduction-to-zksnarks-with-examples-3283b554fc3b) by Christian Lundkvist.

**ZK ("Zero-Knowledge") proofs** (of knowledge) allow a verifier to check that a prover knows a secret information `s` (also called "witness", for example a solution to a problem) by revealing a public proof `p` _without_ revealing the secret `s` at all (and of course the proof `p` must not disclose any information about `s` either). Clearly this also means that a reasonable check procedure `V` must exist so that `V(p)` succeds if and only if the prover really knows `s`.

You can also think of the Zero Knowledge idea as **Zero Information Leak**: if I can prove to you that I know something without telling what it is, then it also means that someone watching can't tell the difference between a proof conversation involving myself (the real prover) and one involving an impostor AKA a "simulator" (TODO check/clarify). This angle is the one actually used in the formal ZK definition.

For ZK proof systems to be robust and used in practice they must of course be **sound**, i.e. the proof can't (realistically) be faked, as well as **complete**, i.e. a zero-knowledge proof about information we know can always be built (no matter what the information).

This idea can be extended to **proofs about the correct computation** of certain operations, rather than mere knowlege of a secret, because encryption/encoding functions exist that have so-called **homomorphic** properties w.r.t. those operations. For a function `E` to be homomorphic w.r.t. a certain operation `f` means that `E(f(v_1, ..., v_n)) = f(E(v_1), ..., E(v_n))`, which is equivalent to saying that **`E` supports the encrypted computation of `f`**. Because of that, a computation's prover needs only providing a verifier with `p = E(f(v_1, ..., v_n))` and `E(v_1), ..., E(v_n)`, but no `v_1,...,v_n` and no `f(v_1, ..., v_n)`, in order to convince the verifier that the prover has performed correctly the `s = f(v_1, ..., v_n)` computation: the "convincing" procedure `V` is a `f(E(v_1), ..., E(v_n)) == E(f(v_1, ..., v_n))` program that calculates `f` on the encrypted inputs and then checks the result against the encrypted output of `f` applied to those inputs. You can also express that by saying that `V(p)` proves `C(p, s)` where `C` is the "special relationship" between `p` and `s`, meaning that the proof `p` implies the knowledge of the secret `s` (due to the fact that `E` supports the encrypted computation of `f`).

Suppose now that `f` is a program that checks a transaction for correctness, let's say a smart contract; if we could find an `E` encryption function that is homomorphic w.r.t. to `f`, this means that we could perform **totally private, provably correct transactions** to any verifier: such a verifier would simply execute the smart contract on its encrypted inputs and check the output against the encrypted result and would be sure that the transaction complies with the constraints defined by the contract without having seen any information about the transaction at all! Think about distributed consensus and the resulting shared world-view (i.e. distributed ledgers / blockchains) while still keeping _all_ details private. This is what [Ethereum](https://www.ethereum.org/) and its enterprise and permissioned incarnation [Quorum](https://www.jpmorgan.com/global/Quorum) (by J.P. Morgan) aim to support.

To concretize this a bit, let's start with an example involving a much simpler calculation: suppose we want to prove that we computed correctly a product of two factors without disclosing neither the factors not the product itself. In this case the secret `w` is the product of secret numbers `a` and `b`, i.e. `a*b`, and the proof of the calculation `x` is the RSA encryption of the product and of the individual factors (i.e. let's say the array `[RSA(a*b), RSA(a), RSA(b)]` to be more concrete). Since RSA is homomorphic w.r.t. the product operation, `RSA(a*b) = RSA(a)*RSA(b)` if and only if `a*b` has been computed correctly from `a` and `b`, so `V = RSA(a*b) == RSA(a)*RSA(b)` proves the "special relationship" `C([RSA(a*b), RSA(a), RSA(b)], a*b)` between the public zero-knowledge proof and the secret.

But how about a generic smart contract that is typically much more sophisticated than a multiplication? Luckily, as it turns out, a fundamental complexity theorem in Computer Science says that _any problem_ that can at least be "feasibly" verified given some kind of suitable information (where "feasibly" means in polynomial time on the size of the problem) can be translated into (or "reduced" to) equivalent "well-known" problem formulations (that incidentally are, unsurprisingly, the most "difficult" such problems). Luckily again, **many real-world problems are of this kind** and can thus be reduced to those "well-known" formulations.

If we could find an encryption/encoding `E` and a "well-known" general formulation `F` for smart contracts such that the encryption `E` was homomorphic w.r.t. _all_ the operations used by `F`, we could simply re-state or "compile" any smart contract in terms of `F`, have the prover run it on its inputs and send the encrypted inputs together with the encrypted output as a public proof to any verifier; the verifier would then check the proof by simply running the same `F`-compiled contract against the encrypted inputs and would finally check the result against the encrypted output.

Of course `F` and more generally the whole process would also have to be _convenient_ from a practical perspective and _efficient_: enter **zkSNARKs**. From a "user" perspective it works as follows:

<div style="margin:auto;width:50%;">
<blockquote class="twitter-tweet" data-lang="it"><p lang="sl" dir="ltr">Generator (C circuit, λ is ☣️):<br>(pk, vk) = G(λ, C)<br>Prover (x pub inp, w sec inp):<br>π = P(pk, x, w)<br>Verifier:<br>V(vk, x, π) == (∃ w s.t. C(x,w))</p>&mdash; Christian Lundkvist (@ChrisLundkvist) <a href="https://twitter.com/ChrisLundkvist/status/799807876982251520?ref_src=twsrc%5Etfw">19 novembre 2016</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>

- Some trusted third entity generates a random secret token `lambda`, takes your smart contract `C` and uses the zkSNARKs Generator `G` on both `C` and `lambda` to calculate two public keys: a prover key `pk` and a verifier key `vk` that encode the "essence" of `C` for the prover and verifier to use during subsequent proof sessions with the zkSNARKs framework. Then it carefully destroys any trace of information about `lambda` (because reconstructing it would allow to build fake proofs!). Note that `pk` and `vk` obtained in this way can be reused at will for a given smart contract `C`; this means that e.g. zCash, that uses a fixed transaction logic for cryptocurrency transactions, can perform this "ceremony" once and for all while more general blockchains that wish to use zSNARKs, such as Ethereum and Quorum, must do it for each and every smart contract.
- The prover passes the prover key, a public information x (the encrypted smart contract output) and the secret it wants to prove knowledge of (the unencrypted smart contract inputs) to zkSNARKs and obtains a public proof p.
- The verifier "zero-knowledge-checks" that the prover has correctly run the smart contract computation by passing the verifier key and the public information x to the zkSNARKs verifier. This verification step can be repeated for as many times as needed by as many parties as needed (which is important e.g. in blockchains).

I now refer you to Christian Reitwiessner [zkSNARKs in a nutshell](https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/) to know how exactly zkSNARKs manages to achieve that and how it does so efficiently.